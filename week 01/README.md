# Задачи за упражнение:
## Задача 1. 
Реализирайте следните функции:
* `void spiralMatrix(int matrix[][100], int n, int m, int arr[])` - Обхожда елементите на матрица от цели числа `matrix` с размерност `n`X`m` спираловидно започващо от горния ляв ъгъл надолу като ги поставя последователно в масива от цели числа `arr`.
  * Пример: <br />`1 2 3`<br />`4 5 6` --> `1 4 7 8 9 6 3 2 5`<br />`7 8 9`
* `void sortArray(int arr[], int n);` - Сортира елементите на масив от цели числа `arr` с размер `n`.
  * Пример: `1 4 7 8 9 6 3 2 5` --> `1 2 3 4 5 6 7 8 9`
* `int binarySearch(int arr[], int n, int index, int x);` - Намира позицията на `x` в масива от цели числа `arr` с размер `n` чрез метода за двоично търсене.
  * Пример: `1 2 3 4 5 6 7 8 9` и `7` --> `6`

Напишете функция `testTask1(int matrix[][100], int n, int m, int x)`, която по дадена матрица `matrix` с размери `n`X`m` и число `x` да превърне матрицата в масив, да го сортира и да намери индекса на елемента `x` в него, като се използват гореспоменатите функции.

## Задача 2. 
Реализирайте следните функции:
* `char* reverseWordsOnly(char* str)` - Обръща отделните думи в `str` (и само тях). Думите са произволни редици от символи. За разделители служат `' '`, `','`, `';'` и `'.'`.
* `char* encode(char* str, char const* alpha)` - Заменя всяка малка латинска буква в символния низ `str` със съответен символ от символния низ `alpha`, където `alpha` е масив от 26 знака. Съответствието е следното: `'a'` се заменя с `salpha[0]`, `'b'` се заменя с `alpha[1]`, ..., `'y'` се заменя с `alpha[24]`, `'z'` се заменя с `alpha[25]`. Останалите символи не се променят.

Напишете функция `teskTask2(char* str, char const* alpha)`, която кодира даден символен низ `str`, като първо прилага функцията `reverseWordsOnly` а след това `encode`.

## Задача X.
Нека да приемем, че лабиринт наричаме двумерен масив от символи, където `'#'` означава стена, `'$'` означава съкровището, `'о'` означава началната позиция, `'_'` означава поле през което можем да преминем.

* Да се реализира функция, която проверява дали от началната позиция може да се достигне съкровището.
* Да се допълни горната функция, така че да брои за колко хода е намерено съкровището и да записва в лабиринта пътя, по който сме минали.
* Да се реализира функция, която намира всички пътища до съкровището.

Препоръчително е да се направят функции `void readLabyrinth()`, `void printLabyrinth()` и `void findStart(int& x, int& y)` съответно за четене на лабиринт, извеждане на лабиринт и намиране на индексите на началната позиция.